import { defineNuxtRouteMiddleware, navigateTo } from "nuxt/app";

type PunctualDoNotRedirects = {
  [key: string]: boolean;
};
type RegexRedirect = {
    "code": number,
    "from": string,
    "to": string
};
type RegexRedirects = {
  [key: string]: RegexRedirects | RegexRedirect[]
};
type PunctualRedirect = {
  "query": string[],
  "code": number,
  "to": string
}
type PunctualRedirects = {
  [key: string]: PunctualRedirect[]
};

export default defineNuxtRouteMiddleware(async (to, _) => {
  if (to.fullPath.includes("robots.txt")) return
  const getTypedRedirects = (redirects: any) =>
    redirects as {
      punctualRedirects: PunctualRedirects,
      regexRedirects: RegexRedirects,
      punctualDoNotRedirect: PunctualDoNotRedirects,
      regexDoNotRedirect: string[]
    };
 
  // if redirection is only server side, skip redirection entirely, else load redirection rules
  let redirects: typeof import("./redirects")["redirects"] | null = null
  if (!<% print(options.alwaysRedirect) %> && !process.server) {
    return
  } else {
    const { redirects: r } = await import("./redirects")
    redirects = r
  }

  // divide redirection rules in punctual redirects and regex redirection rules
  const typedRedirects = getTypedRedirects(redirects);

  const hasTrailingSlash = (path: string) => path.endsWith("/")
  const removeTrailingSlash = (path: string) => hasTrailingSlash(path) ? path.slice(0, -1) : path
  const addTrailingSlash = (path: string) => {
    if (<% print(options.trailingSlash) %>) {
      if (!hasTrailingSlash(path)) {
        return path + "/"
      }
    }
    return path
  }
  const getQueriesFromPath = (path: string) => {
    return path.split("?")?.[1]?.split("&") ?? []
  }

  const joinQueriesAndPath = (path: string, queries: string[]) => {
    if (!queries.length) return path
    return path + "?" + queries.join('&')
  }

  const getUrl = (path: string) => {
    return path.split("?")[0]
  }

  const getQuery = (path: string) => {
    return path.split("?")?.[1] ?? ''
  }

  const findRegexRedirect : (path: string, regexRedirects: RegexRedirects) => RegexRedirect | undefined =  (path: string, regexRedirects: RegexRedirects) => {
    let matchingRedirect : RegexRedirect | undefined;
    for(const key of Object.keys(regexRedirects).filter(k => k != 'root')){
      const regex = new RegExp(key);
      if(regex.test(path)) {
        matchingRedirect = findRegexRedirect(path, regexRedirects[key] as RegexRedirects)
      }
    }
    if(!matchingRedirect && regexRedirects["root"]){
      for(const regexRedirect of (regexRedirects["root"] as RegexRedirect[]).reverse()){
        const regex = new RegExp(regexRedirect.from);
        if (regex.test(path)) {
          matchingRedirect = regexRedirect;
          break;
        }
      }
    }
    return matchingRedirect;
  }

  // redirection only happens server side
  if (process.server || <% print(options.alwaysRedirect) %>) {
    // removing = and trailingSlash, ignore query
    let path = removeTrailingSlash(to.fullPath.endsWith("=")
      ? to.fullPath.slice(0, -1)
      : to.fullPath);

    const query = getQuery(path)
    const urlPath = getUrl(path)
    const queryArray = query ? query.split("&") : [];

    if (to.fullPath !== "/") {  
      // Checking if path is on blacklist (punctual or regex)  
      if(Object.hasOwn(typedRedirects.punctualDoNotRedirect, urlPath)){
        return;
      }else if(typedRedirects.regexDoNotRedirect){
        typedRedirects.regexDoNotRedirect.forEach((r) => {
          const regex = new RegExp(r);
          if (regex.test(path)) {
            return;
          }
        });
      }

      let punctualRedirection : PunctualRedirect | undefined;
      const tentativePunctualRedirections = typedRedirects.punctualRedirects[urlPath] ?? [];
      for(const tentativePunctualRedirection of tentativePunctualRedirections){
        if(tentativePunctualRedirection.query.every(q => queryArray.includes(q))){
          punctualRedirection = tentativePunctualRedirection
        }
      }

      if (typeof punctualRedirection !== "undefined") {
        // join request and redirection queries
        const queryParams = [
          ...getQueriesFromPath(to.fullPath),
          ...punctualRedirection.query
        ]
        const uri = joinQueriesAndPath(addTrailingSlash(punctualRedirection.to), queryParams)
        return navigateTo(uri, {
          redirectCode: punctualRedirection.code,
          external: true,
        });
      }
      // punctual redirects had the priority, now we look for any regex redirections
      let regexRedirection = findRegexRedirect(path, typedRedirects.regexRedirects);
      if(regexRedirection){
        const regex = new RegExp(regexRedirection.from);
        const toPath = addTrailingSlash(urlPath.replace(regex, regexRedirection.to));
        
        const queryParams = [
          ...getQueriesFromPath(to.fullPath),
          ...getQueriesFromPath(toPath)
        ]

        const uri = joinQueriesAndPath(addTrailingSlash(toPath), queryParams)

        return navigateTo(uri, {
          redirectCode: regexRedirection.code,
          external: true,
        });
      }
     
      // trailing-slash
      if (<% print(options.trailingSlash) %>) {
        const originalSplittedPath = to.fullPath.split("?")
        const originalPath = originalSplittedPath[0]

        if (!hasTrailingSlash(originalPath)) {
          originalSplittedPath[0] = addTrailingSlash(originalPath)
          return navigateTo(originalSplittedPath.join("?"), {
            redirectCode: 301,
            external: true
          })
        }
      }
    }
  }
});

